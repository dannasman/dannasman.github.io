
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" />
		<link href="../assets/css/styles.css" rel="stylesheet">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-SC7DNE9Z34"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-SC7DNE9Z34');
        </script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
				TeX: {
				equationNumbers: { autoNumber: "AMS" },
					tagSide: "right"
				},
				tex2jax: {
					inlineMath: [ ['$','$'], ["\\(","\\)"] ],
					displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
					processEscapes: true
				}
			});
			MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function () {
				MathJax.InputJax.TeX.Stack.Item.AMSarray.Augment({
					clearTag() {
						if (!this.global.notags) {
							this.super(arguments).clearTag.call(this);
						}
					}
				});
			});
		</script>

		<script type="text/javascript" async
			src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
		</script>
		<title> Rusty compiler</title>
	</head>
	<body>
		<header>
			<h1 class="header-title">Dan's Blog</h1>
			<nav>
				<ul>
					<li><a href="../index.html">Posts</a></li>
					<li><a href="../about.html">About</a></li>
				</ul>
			</nav>
		</header>
		<article>
			<h1> Rusty compiler</h1>
			<time datetime="2023-01-20">20.01.2023</time>
			<p>This post is a follow-up on the previous <a href="{% post_url 2022-08-26-lexer-written-in-rust %}">post</a> on the topic of writing a lexer and is part of a series of posts in which I try to design and implement a compiler written in Rust. Intermediate code for expressions is the main topic of this post but there has also been some updates on the lexer code and the updates will be display at the end. This post as well as the future posts about the parser are heavily inspired by the legendary <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">dragon book</a> and its example code. The source code for the compiler frontend discussed in this series of posts is available on GitHub (<a href="https://github.com/dannasman/numera">link to the repo</a>).</p>
			<p>Intermediate code is an important part when writing a parser. It implements the nodes used in the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (AST). The nodes can be divided into statements and expressions. Before we get into the implementation of expression nodes let us define a grammar for our language:</p>
			<pre><code class="language-default">
program     -&gt;      block
block       -&gt;      { stmts }
stmts       -&gt;      stmts stmt | Îµ
stmt        -&gt;      id = bool;
            |       if (bool) stmt
            |       if (bool) stmt else stmt
            |       while (bool) stmt
            |       break;
            |       block
bool        -&gt;      bool || join | join
join        -&gt;      join &amp;&amp; equality | equality
equality    -&gt;      equality == rel | equality != rel | rel
rel         -&gt;      expr &lt; expr | expr &lt;= expr | expr &gt;= expr 
                    expr &gt; expr | expr
expr        -&gt;      expr + term | expr - term | term
term        -&gt;      term * unary | term / unary | unary
unary       -&gt;      ! unary | - unary | factor
factor      -&gt;      ( bool ) | id | num | true | false
			</code></pre>
			<p>From the grammar above one can detect the expression nodes by looking for the operators that are associated with expressions. In our language the expression nodes are <code>Id</code> (variables), <code>Arith</code> (arithmetic operators), <code>Temp</code> (helper node to generate <a href="https://en.wikipedia.org/wiki/Three-address_code">three address code</a>), <code>Unary</code> (unary operator <code>-</code>), <code>Constant</code> (numbers and boolean values), <code>And</code>, <code>Or</code>, <code>Rel</code> (relational operators) and <code>Not</code> (unary operator <code>!</code>). These nodes contain functions that allow the parser to turn the token stream generated by the lexer into intermediate representation (IR).</p>
			<p>Let us start by implementing some IR generating functions shared by all the expression nodes. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
use super::lexer::Token;
use std::rc::Rc;
use std::cell::RefCell;
pub trait ExprNode {
    fn emit_label(&amp;self, i: u32) {
        println!("L{}:", i);
    }
    fn emit(&amp;self, s: String) {
        println!("\t{}", s);
    }
    fn emit_jumps(&amp;self, test: String, t: u32, f: u32) {
        if t != 0 &amp;&amp; f != 0 {
            self.emit(format!("if {} goto L{}", test, t));
            self.emit(format!("goto L{}", f));
        } else if t != 0 {
            self.emit(format!("if {} goto L{}", test, t));
        } else if f != 0 {
            self.emit(format!("iffalse {} goto L{}", test, f));
        }
    }
    fn jumping(&amp;self, t: u32, f: u32) {
        self.emit_jumps(self.to_string(), t, f);
    }
    fn to_string(&amp;self) -&gt; String;
}
			</code></pre>
			<p>The <code>Rc</code> and <code>RefCell</code> imports are for later use. The <code>emit_label</code> function emits a label with with given label numer <code>i</code>, <code>emit</code> emits a string <code>s</code>, <code>emit_jumps</code> generates IR code for logical expressions. It is given a string <code>s</code>, which often contains a logical expression, and label numbers <code>t</code> and <code>f</code> for a situation where condition is true and where it is false respectively. <code>jumping</code> calls <code>emit_jumps</code> for expression node itself. <code>to_string</code> gives a string representation of the expression node.</p>
			<p>Now we will define a union of all the expression node types. This makes it easier to link the child nodes to the parent node. Instead of the <code>union</code> type I found it easier to work with <code>enum</code>. Let us also implement some helper functions for the union. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//..
#[derive(Debug, Clone)]
pub enum ExprUnion {
    Id(Box&lt;Id&gt;),
    Arith(Box&lt;Arith&gt;),
    Temp(Box&lt;Temp&gt;),
    Unary(Box&lt;Unary&gt;),
    Constant(Box&lt;Constant&gt;),
    Or(Box&lt;Or&gt;),
    And(Box&lt;And&gt;),
    Not(Box&lt;Not&gt;),
    Rel(Box&lt;Rel&gt;),
}
impl ExprUnion {
    fn gen_expr_string(&amp;self) -&gt; String {
        match self {
            ExprUnion::Id(id) =&gt; id.to_string(),
            ExprUnion::Arith(arith) =&gt; arith.gen().to_string(),
            ExprUnion::Temp(temp) =&gt; temp.to_string(),
            ExprUnion::Unary(unary) =&gt; unary.gen().to_string(),
            ExprUnion::Constant(constant) =&gt; constant.to_string(),
            ExprUnion::Or(or) =&gt; or.gen().to_string(),
            ExprUnion::And(and) =&gt; and.gen().to_string(),
            ExprUnion::Not(not) =&gt; not.gen().to_string(),
            ExprUnion::Rel(rel) =&gt; rel.gen().to_string(),
        }
    }
    fn jumping(&amp;self, t: u32, f: u32) {
        match self {
            ExprUnion::Id(id) =&gt; id.jumping(t, f),
            ExprUnion::Arith(arith) =&gt; arith.jumping(t, f),
            ExprUnion::Temp(temp) =&gt; temp.jumping(t, f),
            ExprUnion::Unary(unary) =&gt; unary.jumping(t, f),
            ExprUnion::Constant(constant) =&gt; constant.jumping(t, f),
            ExprUnion::Or(or) =&gt; or.jumping(t, f),
            ExprUnion::And(and) =&gt; and.jumping(t, f),
            ExprUnion::Not(not) =&gt; not.jumping(t, f),
            ExprUnion::Rel(rel) =&gt; rel.jumping(t, f),
        }
    }
}
			</code></pre>
			<p>The <code>gen_expr_string</code> function generates a three address code string representation of the desired node. The <code>jumping</code> function helps us call the <code>jumping</code> function of the desired expression node. Now we can implement the expression nodes.</p>
			<p>Let us start with <code>Id</code>. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//...
#[derive(Debug, Clone)]
pub struct Id {
    token: Token,
}
impl Id {
    pub fn new(token: Token) -&gt; Self {
        Id { token }
    }
}
impl ExprNode for Id {
    fn to_string(&amp;self) -&gt; String {
        self.token.clone().value_to_string()
    }
}
			</code></pre>
			<p>The <code>Id</code> node simply contains a token <code>Id</code>. <code>Id</code> nodes are used to represent variables in the AST.</p>
			<p><code>Arith</code> node is a bit different. It has two whild nodes which can be a direct value or a new arithmetic operation. When generating the IR we need to make sure that each arithmetic operation is represented in three address code. For example, an  operation represented like</p>
			<pre><code class="language-default">
z = x + y + 2;
			</code></pre>
			<p>is not three address code but</p>
			<pre><code class="language-default">
t1 = x + y;
z = t1 + 2; 
			</code></pre>
			<p>is. This is where the <code>Temp</code> node mentioned earlier comes in. It's purpose is to generate temporary values and it makes three address code IR possible. We will implement it after <code>Arith</code>.</p>
			<p> In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//...
#[derive(Debug, Clone)]
pub struct Arith {
    op: Token,
    temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
    expr1: ExprUnion,
    expr2: ExprUnion,
}
impl Arith {
    pub fn gen(&amp;self) -&gt; Self {
        let mut e1 = self.expr1.clone();
        let mut e2 = self.expr2.clone();
        match e1 {
            ExprUnion::Arith(arith) =&gt; {
                e1 = ExprUnion::Temp(Box::new(arith.reduce()));
            }
            ExprUnion::Unary(unary) =&gt; {
                e1 = ExprUnion::Temp(Box::new(unary.reduce()));
            }
            _ =&gt; (),
        }
        match e2 {
            ExprUnion::Arith(arith) =&gt; {
                e2 = ExprUnion::Temp(Box::new(arith.reduce()));
            }
            ExprUnion::Unary(unary) =&gt; {
                e2 = ExprUnion::Temp(Box::new(unary.reduce()));
            }
            _ =&gt; (),
        }
        Arith::new(self.op.clone(), Rc::clone(&amp;self.temp_count), e1, e2)
    }
    pub fn new(op: Token, temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;, expr1: ExprUnion, expr2: ExprUnion) -&gt; Self {
        Arith {
            op,
            temp_count,
            expr1,
            expr2,
        }
    }
    fn reduce(&amp;self) -&gt; Temp {
        let temp = Temp::new(Rc::clone(&amp;self.temp_count));
        self.emit(format!("{} = {}", temp.to_string(), self.gen().to_string()));
        temp
    }
}
impl ExprNode for Arith {
    fn jumping(&amp;self, t: u32, f: u32) {
        self.emit_jumps(self.to_string(), t, f);
    }
    fn to_string(&amp;self) -&gt; String {
        let e1 = self.expr1.gen_expr_string();
        let e2 = self.expr2.gen_expr_string();
        format!("{} {} {}", e1, self.op.clone().value_to_string(), e2)
    }
}
			</code></pre>
			<p>The <code>gen</code> function helps us generate a three address code representation of the node by reducing the child nodes in case they are unary or arithmetic operators. The <code>reduce</code> function reduces the node itself into a <code>Temp</code> node that is in the form of three address code. <code>jumping</code> creates jumping code for the node. The <code>temp_count</code> field keeps track of the temporary value numbers (<code>t1, t2, t3, ...</code>) and is shared between all nodes that make use of it. It will eventually be initialzed in the <code>Parser</code> struct. <code>Arith</code> uses it when it initializes a new <code>Temp</code> node.</p>
			<p>The next node we will implement is <code>Temp</code>. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//...
#[derive(Debug, Clone)]
pub struct Temp {
    number: u32,
}
impl Temp {
    pub fn new(temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;) -&gt; Self {
        let mut c = temp_count.borrow_mut();
        *c += 1;
        let number = *c;
        drop(c);
        Temp { number }
    }
}
impl ExprNode for Temp {
    fn to_string(&amp;self) -&gt; String {
        format!("t{}", self.number)
    }
}
			</code></pre>
			<p>It is pretty straicht forward. The constructor gets the <code>temp_count</code>, borrows the value, increments it and assigns the incremented value to its field <code>number</code>. The <code>Unary</code> node is quite similar to <code>Arith</code> except that there is only one child node. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//...
#[derive(Debug, Clone)]
pub struct Unary {
    op: Token,
    temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
    expr: ExprUnion,
}
impl Unary {
    pub fn gen(&amp;self) -&gt; Self {
        let mut e = self.expr.clone();
        match e {
            ExprUnion::Arith(arith) =&gt; {
                e = ExprUnion::Temp(Box::new(arith.reduce()));
            }
            ExprUnion::Unary(unary) =&gt; {
                e = ExprUnion::Temp(Box::new(unary.reduce()));
            }
            _ =&gt; (),
        }
        Unary::new(self.op.clone(), Rc::clone(&amp;self.temp_count), e)
    }
    pub fn new(op: Token, temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;, expr: ExprUnion) -&gt; Self {
        Unary {
            op,
            temp_count,
            expr,
        }
    }
    fn reduce(&amp;self) -&gt; Temp {
        let temp = Temp::new(Rc::clone(&amp;self.temp_count));
        self.emit(format!("{} = {}", temp.to_string(), self.gen().to_string()));
        temp
    }
}
impl ExprNode for Unary {
    fn jumping(&amp;self, t: u32, f: u32) {
        self.emit_jumps(self.to_string(), t, f);
    }
    fn to_string(&amp;self) -&gt; String {
        let e = self.expr.gen_expr_string();
        format!("{} {}", self.op.clone().value_to_string(), e)
    }
}
			</code></pre>
			<p>The <code>Constant</code> node is quite similar to <code>Id</code>. The difference is in the <code>jumping</code> function, which needs to handle situations where the constant is boolean. If the constant is <code>true</code> it should emit jump into the label with label number <code>t</code> and to label number <code>f</code> in case it is <code>false</code>. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//...
#[derive(Debug, Clone)]
pub struct Constant {
    constant: Token,
}
impl Constant {
    pub fn new(constant: Token) -&gt; Self {
        Constant { constant }
    }
}
impl ExprNode for Constant {
    fn jumping(&amp;self, t: u32, f: u32) {
        match self.constant {
            Token::True(_) =&gt; {
                if t != 0 {
                    self.emit(format!("goto L{}", t));
                }
            }
            Token::False(_) =&gt; {
                if f != 0 {
                    self.emit(format!("goto L{}", f));
                }
            }
            _ =&gt; ()
        }
    }
    fn to_string(&amp;self) -&gt; String {
        self.constant.clone().value_to_string()
    }
}
			</code></pre>
			<p>To generate three address code IR the <code>Or</code> and <code>And</code> nodes sometimes need to generate a lot of jumping code. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//...
#[derive(Debug, Clone)]
pub struct Or {
    label: Rc&lt;RefCell&lt;u32&gt;&gt;,
    temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
    op: Token,
    expr1: ExprUnion,
    expr2: ExprUnion,
}
impl Or {
    fn gen(&amp;self) -&gt; Temp {
        let mut l = self.label.borrow_mut();
        *l += 1;
        let f = *l;
        *l += 1;
        let a = *l;
        drop(l);
        let temp = Temp::new(Rc::clone(&amp;self.temp_count));
        self.jumping(0, f);
        self.emit(format!("{} = true", temp.to_string()));
        self.emit(format!("goto L{}", a));
        self.emit_label(f);
        self.emit(format!("{} = false", temp.to_string()));
        self.emit_label(a);
        temp
    }
    pub fn new(
        label: Rc&lt;RefCell&lt;u32&gt;&gt;,
        temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
        op: Token,
        expr1: ExprUnion,
        expr2: ExprUnion,
    ) -&gt; Self {
        Or {
            label,
            temp_count,
            op,
            expr1,
            expr2,
        }
    }
}
impl ExprNode for Or {
    fn jumping(&amp;self, t: u32, f: u32) {
        let mut new_label = t;
        if t == 0 {
            let mut l = self.label.borrow_mut();
            *l += 1;
            new_label = *l;
            drop(l);
        }
        self.expr1.jumping(new_label, 0);
        self.expr2.jumping(t, f);
        if t == 0 {
            self.emit_label(new_label);
        }
    }
    fn to_string(&amp;self) -&gt; String {
        let e1 = self.expr1.gen_expr_string();
        let e2 = self.expr2.gen_expr_string();
        format!("{} {} {}", e1, self.op.clone().value_to_string(), e2)
    }
}
#[derive(Debug, Clone)]
pub struct And {
    label: Rc&lt;RefCell&lt;u32&gt;&gt;,
    temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
    op: Token,
    expr1: ExprUnion,
    expr2: ExprUnion,
}
impl And {
    fn gen(&amp;self) -&gt; Temp {
        let mut l = self.label.borrow_mut();
        *l += 1;
        let f = *l;
        *l += 1;
        let a = *l;
        drop(l);
        let temp = Temp::new(Rc::clone(&amp;self.temp_count));
        self.jumping(0, f);
        self.emit(format!("{} = true", temp.to_string()));
        self.emit(format!("goto L{}", a));
        self.emit_label(f);
        self.emit(format!("{} = false", temp.to_string()));
        self.emit_label(a);
        temp
    }
    pub fn new(
        label: Rc&lt;RefCell&lt;u32&gt;&gt;,
        temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
        op: Token,
        expr1: ExprUnion,
        expr2: ExprUnion,
    ) -&gt; Self {
        And {
            label,
            temp_count,
            op,
            expr1,
            expr2,
        }
    }
}
impl ExprNode for And {
    fn jumping(&amp;self, t: u32, f: u32) {
        let mut new_label = f;
        if f == 0 {
            let mut l = self.label.borrow_mut();
            *l += 1;
            new_label = *l;
            drop(l);
        }
        self.expr1.jumping(0, new_label);
        self.expr2.jumping(t, f);
        if f == 0 {
            self.emit_label(new_label);
        }
    }
    fn to_string(&amp;self) -&gt; String {
        let e1 = self.expr1.gen_expr_string();
        let e2 = self.expr2.gen_expr_string();
        format!("{} {} {}", e1, self.op.clone().value_to_string(), e2)
    }
}
			</code></pre>
			<p>Both nodes have a <code>label</code> field which is a bit similar to <code>temp_count</code>. Number of labels is a single <code>u32</code> value that is shared among all the nodes that need it. The <code>gen</code> functions of the nodes generate labels to jump to depending on the outcome of the operator on the expressions. It then assigns a temporary variable to <code>true</code> or <code>false</code> depending on which label the jump was made. The <code>jumping</code> functions are responsible for generating the jumping code of the child nodes.</p>
			<p>The <code>Not</code> node is simple. It shares the same <code>gen</code> function with <code>Or</code> and <code>And</code>. For <code>jumping</code> it just calls the <code>jumping</code> of the child node. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//...
#[derive(Debug, Clone)]
pub struct Not {
    op: Token,
    label: Rc&lt;RefCell&lt;u32&gt;&gt;,
    temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
    expr: ExprUnion,
}
impl Not {
    fn gen(&amp;self) -&gt; Temp {
        let mut l = self.label.borrow_mut();
        *l += 1;
        let f = *l;
        *l += 1;
        let a = *l;
        drop(l);
        let temp = Temp::new(Rc::clone(&amp;self.temp_count));
        self.jumping(0, f);
        self.emit(format!("{} = true", temp.to_string()));
        self.emit(format!("goto L{}", a));
        self.emit_label(f);
        self.emit(format!("{} = false", temp.to_string()));
        self.emit_label(a);
        temp
    }
    pub fn new(
        op: Token,
        label: Rc&lt;RefCell&lt;u32&gt;&gt;,
        temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
        expr: ExprUnion,
    ) -&gt; Self {
        Not {
            op,
            label,
            temp_count,
            expr,
        }
    }
}
impl ExprNode for Not {
    fn jumping(&amp;self, t: u32, f: u32) {
        self.expr.jumping(f, t);
    }
    fn to_string(&amp;self) -&gt; String {
        let e = self.expr.gen_expr_string();
        format!("{} {}", self.op.clone().value_to_string(), e)
    }
}
			</code></pre>
			<p>Last but not least we have the <code>Rel</code> node. It shares the same <code>gen</code> functions with the rest of the logical expression nodes. For <code>jumping</code> it needs to reduce the its child nodes if they are <code>Arith</code> or <code>Unary</code>. Then it just emits jumps to <code>t</code> or <code>f</code> based on how it evaluates. In <code>inter.rs</code>:</p>
			<pre><code class="language-rust">
//...
#[derive(Debug, Clone)]
pub struct Rel {
    op: Token,
    label: Rc&lt;RefCell&lt;u32&gt;&gt;,
    temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
    expr1: ExprUnion,
    expr2: ExprUnion,
}
impl Rel {
    fn gen(&amp;self) -&gt; Temp {
        let mut l = self.label.borrow_mut();
        *l += 1;
        let f = *l;
        *l += 1;
        let a = *l;
        drop(l);
        let temp = Temp::new(Rc::clone(&amp;self.temp_count));
        self.jumping(0, f);
        self.emit(format!("{} = true", temp.to_string()));
        self.emit(format!("goto L{}", a));
        self.emit_label(f);
        self.emit(format!("{} = false", temp.to_string()));
        self.emit_label(a);
        temp
    }
    pub fn new(
        op: Token,
        label: Rc&lt;RefCell&lt;u32&gt;&gt;,
        temp_count: Rc&lt;RefCell&lt;u32&gt;&gt;,
        expr1: ExprUnion,
        expr2: ExprUnion,
    ) -&gt; Self {
        Rel {
            op,
            label,
            temp_count,
            expr1,
            expr2,
        }
    }
}
impl ExprNode for Rel {
    fn jumping(&amp;self, t: u32, f: u32) {
        let mut e1 = self.expr1.clone();
        let mut e2 = self.expr2.clone();
        match e1 {
            ExprUnion::Arith(arith) =&gt; {
                e1 = ExprUnion::Temp(Box::new(arith.reduce()));
            }
            ExprUnion::Unary(unary) =&gt; {
                e1 = ExprUnion::Temp(Box::new(unary.reduce()));
            }
            _ =&gt; (),
        }
        match e2 {
            ExprUnion::Arith(arith) =&gt; {
                e2 = ExprUnion::Temp(Box::new(arith.reduce()));
            }
            ExprUnion::Unary(unary) =&gt; {
                e2 = ExprUnion::Temp(Box::new(unary.reduce()));
            }
            _ =&gt; (),
        }
        let test = format!(
            "{} {} {}",
            e1.gen_expr_string(),
            self.op.clone().value_to_string(),
            e2.gen_expr_string()
        );
        self.emit_jumps(test, t, f);
    }
    fn to_string(&amp;self) -&gt; String {
        let e1 = self.expr1.gen_expr_string();
        let e2 = self.expr2.gen_expr_string();
        format!("{} {} {}", e1, self.op.clone().value_to_string(), e2)
    }
}
			</code></pre>
			<p>Phew! That conclued all the intermediate expression code in our rusty compiler so far. I hope this post was not too long and difficult to read. If you find any flaws in the code or have suggestions for improvements please contact me!</p>
			<h2>Updated lexer code</h3>
			<p>Updated lexer code in <code>lexer.rs</code>:</p>
			<pre><code class="language-rust">
use std::collections::{HashMap, LinkedList};
#[derive(Debug, Clone)]
pub enum Token {
    Num(f64), // numbers are currently float only, maybe splitting into Num(u64) and Real(f64) later...
    Id(String),
    True(String),
    False(String),
    If(String),
    Else(String),
    While(String),
    And(String),
    Or(String),
    Eql(String),
    Ne(String),
    Le(String),
    Ge(String),
    Lt(String),
    Gt(String),
    Asgn(String),
    Not(String),
    Add(String),
    Sub(String),
    Mul(String),
    Div(String),
    Lcb(String),
    Rcb(String),
    Lrb(String),
    Rrb(String),
    Scol(String),
}
impl Token {
    pub fn value_to_string(self) -&gt; String {
        match self {
            Token::Num(i) =&gt; format!("{}", i),
            Token::Id(s) =&gt; s,
            Token::True(s) =&gt; s,
            Token::False(s) =&gt; s,
            Token::If(s) =&gt; s,
            Token::Else(s) =&gt; s,
            Token::While(s) =&gt; s,
            Token::And(s) =&gt; s,
            Token::Or(s) =&gt; s,
            Token::Eql(s) =&gt; s,
            Token::Ne(s) =&gt; s,
            Token::Le(s) =&gt; s,
            Token::Ge(s) =&gt; s,
            Token::Lt(s) =&gt; s,
            Token::Gt(s) =&gt; s,
            Token::Asgn(s) =&gt; s,
            Token::Not(s) =&gt; s,
            Token::Add(s) =&gt; s,
            Token::Sub(s) =&gt; s,
            Token::Mul(s) =&gt; s,
            Token::Div(s) =&gt; s,
            Token::Lcb(s) =&gt; s,
            Token::Rcb(s) =&gt; s,
            Token::Lrb(s) =&gt; s,
            Token::Rrb(s) =&gt; s,
            Token::Scol(s) =&gt; s,
        }
    }
}
#[derive(Debug, Clone)]
pub struct Lexer {
    pub tokens: LinkedList&lt;Token&gt;,
    words: HashMap&lt;String, Token&gt;,
    lineno: u32,
}
impl Lexer {
    pub fn new() -&gt; Lexer {
        Lexer {
            tokens: LinkedList::new(),
            words: HashMap::from([
                (String::from("true"), Token::True(String::from("true"))),
                (String::from("false"), Token::False(String::from("false"))),
                (String::from("if"), Token::If(String::from("if"))),
                (String::from("else"), Token::Else(String::from("else"))),
                (String::from("while"), Token::While(String::from("while"))),
            ]),
            lineno: 1,
        }
    }
    pub fn lex(&amp;mut self, input: &amp;str) {
        let mut it = input.chars().peekable();
        while let Some(&amp;c) = it.peek() {
            match c {
                ' ' | '\t' =&gt; {
                    it.next();
                }
                '\n' =&gt; {
                    self.lineno += 1;
                    it.next();
                }
                '&amp;' =&gt; {
                    it.next();
                    let ch = it.peek();
                    if let Some('&amp;') = ch {
                        self.tokens.push_back(Token::And(String::from("&amp;&amp;")));
                        it.next();
                    } else {
                        self.tokens.push_back(Token::Id(String::from("&amp;")));
                    };
                }
                '|' =&gt; {
                    it.next();
                    let ch = it.peek();
                    if let Some('|') = ch {
                        self.tokens.push_back(Token::Or(String::from("||")));
                        it.next();
                    } else {
                        self.tokens.push_back(Token::Id(String::from("|")));
                    };
                }
                '=' =&gt; {
                    it.next();
                    let ch = it.peek();
                    if let Some('=') = ch {
                        self.tokens.push_back(Token::Eql(String::from("==")));
                        it.next();
                    } else {
                        self.tokens.push_back(Token::Asgn(String::from("=")));
                    };
                }
                '!' =&gt; {
                    it.next();
                    let ch = it.peek();
                    if let Some('=') = ch {
                        self.tokens.push_back(Token::Ne(String::from("!=")));
                        it.next();
                    } else {
                        self.tokens.push_back(Token::Not(String::from("!")));
                    };
                }
                '&lt;' =&gt; {
                    it.next();
                    let ch = it.peek();
                    if let Some('=') = ch {
                        self.tokens.push_back(Token::Le(String::from("&lt;=")));
                        it.next();
                    } else {
                        self.tokens.push_back(Token::Lt(String::from("&lt;")));
                    };
                }
                '&gt;' =&gt; {
                    it.next();
                    let ch = it.peek();
                    if let Some('=') = ch {
                        self.tokens.push_back(Token::Ge(String::from("&gt;=")));
                        it.next();
                    } else {
                        self.tokens.push_back(Token::Gt(String::from("&gt;")));
                    };
                }
                '+' =&gt; {
                    self.tokens.push_back(Token::Add(String::from("+")));
                    it.next();
                }
                '-' =&gt; {
                    self.tokens.push_back(Token::Sub(String::from("-")));
                    it.next();
                }
                '*' =&gt; {
                    self.tokens.push_back(Token::Mul(String::from("*")));
                    it.next();
                }
                '/' =&gt; {
                    self.tokens.push_back(Token::Div(String::from("/")));
                    it.next();
                }
                '{' =&gt; {
                    self.tokens.push_back(Token::Lcb(String::from("{")));
                    it.next();
                }
                '}' =&gt; {
                    self.tokens.push_back(Token::Rcb(String::from("}")));
                    it.next();
                }
                '(' =&gt; {
                    self.tokens.push_back(Token::Lrb(String::from("(")));
                    it.next();
                }
                ')' =&gt; {
                    self.tokens.push_back(Token::Rrb(String::from(")")));
                    it.next();
                }
                ';' =&gt; {
                    self.tokens.push_back(Token::Scol(String::from(";")));
                    it.next();
                }
                '0'..='9' =&gt; {
                    let mut n = c
                        .to_string()
                        .parse::&lt;f64&gt;()
                        .expect("Character not a digit.");
                    it.next();
                    let mut digitch = it.peek();
                    while let Some(&amp;i) = digitch {
                        if !i.is_ascii_digit() {
                            if i == '.' {
                                let mut d = 10.0;
                                it.next();
                                digitch = it.peek();
                                while let Some(&amp;j) = digitch {
                                    if !j.is_ascii_digit() {
                                        digitch = None;
                                    } else {
                                        let f = j
                                            .to_string()
                                            .parse::&lt;f64&gt;()
                                            .expect("Character not a digit.");
                                        n += f / d;
                                        d *= 10.0;
                                        it.next();
                                        digitch = it.peek();
                                    }
                                }
                            } else {
                                digitch = None;
                            }
                        } else {
                            let digit = i
                                .to_string()
                                .parse::&lt;f64&gt;()
                                .expect("Character not a digit.");
                            n = n * 10.0 + digit;
                            it.next();
                            digitch = it.peek();
                        }
                    }
                    self.tokens.push_back(Token::Num(n));
                }
                'A'..='Z' | 'a'..='z' =&gt; {
                    let mut s = String::new();
                    s.push(c);
                    it.next();
                    let mut ch = it.peek();
                    while let Some(&amp;i) = ch {
                        if !i.is_ascii_digit() &amp;&amp; !i.is_alphabetic() {
                            ch = None;
                        } else {
                            s.push(i);
                            it.next();
                            ch = it.peek();
                        }
                    }
                    match self.words.get(&amp;s) {
                        Some(t) =&gt; self.tokens.push_back(Token::clone(t)),
                        None =&gt; {
                            self.tokens.push_back(Token::Id(s.clone()));
                            self.words.insert(s.clone(), Token::Id(s));
                        }
                    }
                }
                _ =&gt; {
                    self.tokens.push_back(Token::Id(String::from(c)));
                    it.next();
                }
            }
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn correct_amount_of_tokens() {
        let input = String::from("1 _ != &amp;&amp; =ok 3.4 1.0=_");
        let mut lexer = Lexer::new();
        lexer.lex(&amp;input);
        assert_eq!(10, lexer.tokens.len())
    }
    #[test]
    fn correct_token_types() {
        let input = String::from("1 _ while { != &amp;&amp; =ok 3.4 1.0=_ true false if else true1");
        let mut lexer = Lexer::new();
        lexer.lex(&amp;input);
        let output = format!("{:?}", lexer.tokens);
        assert_eq!(
            r#"[Num(1.0), Id("_"), While("while"), Lcb("{"), Ne("!="), And("&amp;&amp;"), Asgn("="), Id("ok"), Num(3.4), Num(1.0), Asgn("="), Id("_"), True("true"), False("false"), If("if"), Else("else"), Id("true1")]"#,
            output
        )
    }
    #[test]
    fn correct_block_handling() {
        let input = String::from("while {(*/;)}");
        let mut lexer = Lexer::new();
        lexer.lex(&amp;input);
        let output = format!("{:?}", lexer.tokens);
        assert_eq!(
            r#"[While("while"), Lcb("{"), Lrb("("), Mul("*"), Div("/"), Scol(";"), Rrb(")"), Rcb("}")]"#,
            output
        )
    }
}
			</code></pre>
		</article>
		<footer>
			<p>In this blog you can find posts about projects I have been working on.</p>
			<ul>
				<li><a href="https://github.com/dannasman">GitHub</a></li>
				<li>dan.nasman@gmail.com</li>
			</ul>
		</footer>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js"></script>
	</body>
</html>
